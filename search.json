[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Functional Programming Notes",
    "section": "",
    "text": "Preface\nThis is a Quarto book.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee for additional discussion of literate programming.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "reading.html",
    "href": "reading.html",
    "title": "2  Reading List",
    "section": "",
    "text": "2.1 Logo",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Reading List</span>"
    ]
  },
  {
    "objectID": "reading.html#logo",
    "href": "reading.html#logo",
    "title": "2  Reading List",
    "section": "",
    "text": "Computer Science Logo Style, Vol 1 - 3. Harvey.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Reading List</span>"
    ]
  },
  {
    "objectID": "reading.html#lisp",
    "href": "reading.html#lisp",
    "title": "2  Reading List",
    "section": "2.2 Lisp",
    "text": "2.2 Lisp\n\nCommon Lisp - A Gentle Introduction to Symbolic Computation. Touretzky\nCommon Lisp - An Interactive Approach. Shapiro\nLand of Lisp - Learn to Program in Lisp, One Game at a Time. Barski\nCommon Lisp - Paul Graham\nOn Lisp - Advanced Techniques for Common Lisp - Paul Graham\nLisp - Let Over Lambda. Hoyte\nLisp in Small Pieces - Queinnec\nThe Anatomy of Lisp - John Allen",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Reading List</span>"
    ]
  },
  {
    "objectID": "reading.html#scheme",
    "href": "reading.html#scheme",
    "title": "2  Reading List",
    "section": "2.3 Scheme",
    "text": "2.3 Scheme\n\nSimply Scheme. Harvey\nConcrete Abstractions - an Introduction to Computer Science using Scheme. Hailperin\nAn Introduction to Scheme. Jerry Smith\nExploring Computer Science with Scheme. Oliver Grillmeyer\nProgramming in Scheme. Eisenberg\nProgramming and Metaprogramming in Scheme. Jon Pearce\nStructure and Interpretation of Computer Programs\nAlgorithms for Functional Programming. John David Stone",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Reading List</span>"
    ]
  },
  {
    "objectID": "reading.html#racket",
    "href": "reading.html#racket",
    "title": "2  Reading List",
    "section": "2.4 Racket",
    "text": "2.4 Racket\n\nHow to Design Programs - an Introduction to Programming and Computing. Felleisen\nRealm of Racket - Learn to Program, One Game at a Time!. Van Horn, Felleisen\nRacket Programming the Fun Way - From Strings to Turing Machines. James Stelly\nDie Macht der Abstraktion. Klaeren",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Reading List</span>"
    ]
  },
  {
    "objectID": "reading.html#haskell",
    "href": "reading.html#haskell",
    "title": "2  Reading List",
    "section": "2.5 Haskell",
    "text": "2.5 Haskell\n\nFunctional Programming. Fokker\nIntroduction to Functional Programming using Haskell. Bird\nIntroduction to Functional Programming Systems Using Haskell. Antony Davie\nThinking Functionally with Haskell - Richard Bird\nHaskell - The Craft of Functional Programming. Thompson\nProgramming in Haskell. Graham Hutton\nReasoned Programming. Broda\nIntroduction to Computation, Haskell, Logic, and Automata. Wadler\nAlgorithm Design in Haskell. Bird\nThe Fun of Programming - Gibbons\nAlgebra of Programming. Bird, de Moor",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Reading List</span>"
    ]
  },
  {
    "objectID": "reading.html#sml",
    "href": "reading.html#sml",
    "title": "2  Reading List",
    "section": "2.6 SML",
    "text": "2.6 SML\n\nElements of Fucntional Programming with SML. Reade\nIntroduction to Programming Using SML. Hansel, Rischel\nFunctional Programming Using SML. Wikstroem\nElements of ML Programming. Ullman\nPurely Functional Data Structures. Okasaki",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Reading List</span>"
    ]
  },
  {
    "objectID": "reading.html#ocaml",
    "href": "reading.html#ocaml",
    "title": "2  Reading List",
    "section": "2.7 OCAML",
    "text": "2.7 OCAML\n\nThink OCAML - How to Think Like a Computer Scientist. Monje, Downey\nOCaml from the very Beginning. Whitington\nMore OCaml. Whitignton\nOCaml - Functional Programming for the Masses. Madhavapeddy",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Reading List</span>"
    ]
  },
  {
    "objectID": "reading.html#implementation-and-practical-aspects",
    "href": "reading.html#implementation-and-practical-aspects",
    "title": "2  Reading List",
    "section": "2.8 Implementation and Practical Aspects",
    "text": "2.8 Implementation and Practical Aspects\n\nFunctional Programming - Application and Implementation. Henderson\nFunctional Programming. Field, Harrison\nThe Architecture of Symbolic Computers",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Reading List</span>"
    ]
  },
  {
    "objectID": "reading.html#general",
    "href": "reading.html#general",
    "title": "2  Reading List",
    "section": "2.9 General",
    "text": "2.9 General\n\nFunctional Programming - Practice and Theory. Bruce J. MacLennan\nEquations, Models, and Programs - a Mathematical Introduction to Computer Science. Myers.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Reading List</span>"
    ]
  },
  {
    "objectID": "reading.html#theory",
    "href": "reading.html#theory",
    "title": "2  Reading List",
    "section": "2.10 Theory",
    "text": "2.10 Theory\n\nAn Introduction to Functional Programmming Through Lambda Calculus. Michaelson\nIntroduction to Functional Programming. Gordon\nIntroduction to Functional Programming. Harrison\nType Theory & Functional Programming. Thompson",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Reading List</span>"
    ]
  },
  {
    "objectID": "reading.html#python",
    "href": "reading.html#python",
    "title": "2  Reading List",
    "section": "2.11 Python",
    "text": "2.11 Python\n\nA Functional Start to Computing with Python. Herman\nSICP with Python",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Reading List</span>"
    ]
  },
  {
    "objectID": "reading.html#c",
    "href": "reading.html#c",
    "title": "2  Reading List",
    "section": "2.12 C",
    "text": "2.12 C\n\nFunctional C. Muller",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Reading List</span>"
    ]
  },
  {
    "objectID": "logo/intro.html",
    "href": "logo/intro.html",
    "title": "3  Introduction to Logo",
    "section": "",
    "text": "3.1 Basic Notions",
    "crumbs": [
      "Logo",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introduction to Logo</span>"
    ]
  },
  {
    "objectID": "logo/intro.html#basic-notions",
    "href": "logo/intro.html#basic-notions",
    "title": "3  Introduction to Logo",
    "section": "",
    "text": "3.1.1 Words and Lists\nBasic building blocks of logo programs are words. Everything in logo is a word. By default logo interprets a word as a name of a procedure and tries to carry it out. Examples of procedures are sum, print. We will define procedures more carefully below.\nIn order for a word to be interpreted as itself, and not as a name of a procedure it must be escaped.\nE.g.\nprint hello\nwill not print hello, but will try interpret hello as a name of a procedure, and output and error. A word is escaped by prepending it with a quote like this: \"hello. For this reason escaping is also called quoting.\nSo\nprint \"hello\nwill print hello.\nNumeric words are automatically escaped. That is, print 2 and print \"2 are the same. It makes sense since procedure names can not be numbers, so numbers are automatically understood to evaluate to themselves.\nList is simply a combination of multiple words. All logo programs are lists. Logo evaluates a list by evaluating the procedures contained in the list. e.g.\nprint sum 3 2\nJust as words can be escaped, so can be lists. In that case logo will not try to evaluate the list and carry out the computation, rather the list will be evaluated to itself. Lists are escaped by enclosing them in square brackets. e.g.\n[print sum 3 2]\nwill not print 5. It is simply the list itself. Note that this is not a complete logo instruction. (We will carefully define what an instruction is below). The print procedure is flexible and accepts not only words but also (escaped) lists. So we can supply the above list to it.:\nprint [print sum 3 2]\nThis will print print sum 3 2\nEscaped words or escaped lists that evaluate to themselves are called data.\nLists are very flexible and can contain different sorts of data, including other lists:\n[[1 apple] 2 [banana 15 cherry]]\nAbove list contains two lists and one number. It is a nested list. A list that is not nested, like [banana 15 cherry] is called a flat list of a sentence.\nThis is different to many other languages, where lists usually must contain objects or data of the same type.\n\n\n3.1.2 Procedures and Instructions\nprocedures are programs that carry out computations. e.g. print, sum are names of procedures. In conventional programming languages there are many forms of statements that achieve certain things, like assignment statement, if statement, while statement, all having their unique syntax rules. In lisp-like languages this is much simpler. There is only one type of statement: procedure invocation.\nA procedure is a name of a program, not a concrete instance of it. To carry out a concrete computation, a procedure must be supplied with information (data). Doing this is called invoking a procedure. E.g. sum 3 2, print 10. Different procedures accept different number of data. E.g. sum expects two words, while print expects a single one.\nThere are two type of procedures:\n\ncommands: commands have effects when invoked. Effects change something in the state of the computer, e.g. print\noperations: operations return values / data when invoked. They do not change the state of the computer. e.g. sum. Another way to say is that operations are evaluated when invoked.\n\nsince operations return values, they can be used in place of data as an input to a procedure. We saw it with print:\nprint sum 3 2\nSince invoked operations are values, they can be supplied to operations as inputs. This can be done indefinitely and such combinations are called expressions. More formally expression are defined inductively as follows:\n\ndata are expressions.\nif an operation op expects n inputs, and e1,..., en are expressions. Then op e1 ... en is an expression.\n\nAn instruction is invocation of one or more procedures. E.g. print sum 3 2 or print 10. More formally an instruction is a list, where the first word is a command and the rest of the words are expressions that evaluate to inputs necessary to carry out the command. E.g.:\nprint sum 3 2\nprint is a command and it expects single datum. sum 3 2 is an expression evaluating to 5, which in turn is passed to print as input.\nA procedure is described (specified) by the following:see 1\n\nIs it a command or an operation?\nHow many inputs does it accept?\nWhat are the types of each of the inputs? (word, list or array)?\nIf the procedure is an operation, what is the output? (Its description and type) If the procedure is a command what is the effect? (The description of the effect) .\n\n\n\n3.1.3 Manipulating Words and Lists\n\n\n3.1.4 References\n\n\n1. Harvey, B. Computer Science\nLogo Style: Volume 3. (MIT Press,\nCambridge, Mass, 1997).",
    "crumbs": [
      "Logo",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introduction to Logo</span>"
    ]
  },
  {
    "objectID": "fokker/ch1/notes.html",
    "href": "fokker/ch1/notes.html",
    "title": "4  Intro to FP with Gofer",
    "section": "",
    "text": "4.1",
    "crumbs": [
      "Gofer",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Intro to FP with Gofer</span>"
    ]
  }
]